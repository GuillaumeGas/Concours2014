# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_contest', [dirname(__file__)])
        except ImportError:
            import _contest
            return _contest
        if fp is not None:
            try:
                _mod = imp.load_module('_contest', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _contest = swig_import_helper()
    del swig_import_helper
else:
    import _contest
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _contest.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _contest.SwigPyIterator_value(self)
    def incr(self, n=1): return _contest.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _contest.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _contest.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _contest.SwigPyIterator_equal(self, *args)
    def copy(self): return _contest.SwigPyIterator_copy(self)
    def next(self): return _contest.SwigPyIterator_next(self)
    def __next__(self): return _contest.SwigPyIterator___next__(self)
    def previous(self): return _contest.SwigPyIterator_previous(self)
    def advance(self, *args): return _contest.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _contest.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _contest.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _contest.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _contest.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _contest.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _contest.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _contest.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

LOGIN_OK = _contest.LOGIN_OK
LOGIN_NO_MORE_ROOM = _contest.LOGIN_NO_MORE_ROOM
LOGIN_INVALID = _contest.LOGIN_INVALID
LOGIN_ALREADY_USED = _contest.LOGIN_ALREADY_USED
LOGIN_NETWORK_ERROR = _contest.LOGIN_NETWORK_ERROR
ROUND_NORMAL = _contest.ROUND_NORMAL
ROUND_END_OF_GAME = _contest.ROUND_END_OF_GAME
ROUND_NETWORK_ERROR = _contest.ROUND_NETWORK_ERROR
class GameInfos(_object):
    """Proxy of C++ GameInfos class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GameInfos, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GameInfos, name)
    __repr__ = _swig_repr
    __swig_setmethods__["playerId"] = _contest.GameInfos_playerId_set
    __swig_getmethods__["playerId"] = _contest.GameInfos_playerId_get
    if _newclass:playerId = _swig_property(_contest.GameInfos_playerId_get, _contest.GameInfos_playerId_set)
    __swig_setmethods__["playerCount"] = _contest.GameInfos_playerCount_set
    __swig_getmethods__["playerCount"] = _contest.GameInfos_playerCount_get
    if _newclass:playerCount = _swig_property(_contest.GameInfos_playerCount_get, _contest.GameInfos_playerCount_set)
    __swig_setmethods__["totalRoundCount"] = _contest.GameInfos_totalRoundCount_set
    __swig_getmethods__["totalRoundCount"] = _contest.GameInfos_totalRoundCount_get
    if _newclass:totalRoundCount = _swig_property(_contest.GameInfos_totalRoundCount_get, _contest.GameInfos_totalRoundCount_set)
    __swig_setmethods__["currentRoundId"] = _contest.GameInfos_currentRoundId_set
    __swig_getmethods__["currentRoundId"] = _contest.GameInfos_currentRoundId_get
    if _newclass:currentRoundId = _swig_property(_contest.GameInfos_currentRoundId_get, _contest.GameInfos_currentRoundId_set)
    __swig_setmethods__["planetCount"] = _contest.GameInfos_planetCount_set
    __swig_getmethods__["planetCount"] = _contest.GameInfos_planetCount_get
    if _newclass:planetCount = _swig_property(_contest.GameInfos_planetCount_get, _contest.GameInfos_planetCount_set)
    __swig_setmethods__["resources"] = _contest.GameInfos_resources_set
    __swig_getmethods__["resources"] = _contest.GameInfos_resources_get
    if _newclass:resources = _swig_property(_contest.GameInfos_resources_get, _contest.GameInfos_resources_set)
    __swig_setmethods__["scanCountLimit"] = _contest.GameInfos_scanCountLimit_set
    __swig_getmethods__["scanCountLimit"] = _contest.GameInfos_scanCountLimit_get
    if _newclass:scanCountLimit = _swig_property(_contest.GameInfos_scanCountLimit_get, _contest.GameInfos_scanCountLimit_set)
    __swig_setmethods__["shipCost"] = _contest.GameInfos_shipCost_set
    __swig_getmethods__["shipCost"] = _contest.GameInfos_shipCost_get
    if _newclass:shipCost = _swig_property(_contest.GameInfos_shipCost_get, _contest.GameInfos_shipCost_set)
    def __repr__(self):
        return type(self).__name__+'('+', '.join([k+':'+str(v(self)) for k,v in self.__swig_getmethods__.items()])+')'

    def __init__(self): 
        """__init__(self) -> GameInfos"""
        this = _contest.new_GameInfos()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_GameInfos
    __del__ = lambda self : None;
GameInfos_swigregister = _contest.GameInfos_swigregister
GameInfos_swigregister(GameInfos)

class Planet(_object):
    """Proxy of C++ Planet class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Planet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Planet, name)
    __repr__ = _swig_repr
    __swig_setmethods__["planetId"] = _contest.Planet_planetId_set
    __swig_getmethods__["planetId"] = _contest.Planet_planetId_get
    if _newclass:planetId = _swig_property(_contest.Planet_planetId_get, _contest.Planet_planetId_set)
    __swig_setmethods__["resources"] = _contest.Planet_resources_set
    __swig_getmethods__["resources"] = _contest.Planet_resources_get
    if _newclass:resources = _swig_property(_contest.Planet_resources_get, _contest.Planet_resources_set)
    __swig_setmethods__["shipBuildCountLimit"] = _contest.Planet_shipBuildCountLimit_set
    __swig_getmethods__["shipBuildCountLimit"] = _contest.Planet_shipBuildCountLimit_get
    if _newclass:shipBuildCountLimit = _swig_property(_contest.Planet_shipBuildCountLimit_get, _contest.Planet_shipBuildCountLimit_set)
    __swig_setmethods__["shipCount"] = _contest.Planet_shipCount_set
    __swig_getmethods__["shipCount"] = _contest.Planet_shipCount_get
    if _newclass:shipCount = _swig_property(_contest.Planet_shipCount_get, _contest.Planet_shipCount_set)
    __swig_setmethods__["doubleSpeedRemainingTurns"] = _contest.Planet_doubleSpeedRemainingTurns_set
    __swig_getmethods__["doubleSpeedRemainingTurns"] = _contest.Planet_doubleSpeedRemainingTurns_get
    if _newclass:doubleSpeedRemainingTurns = _swig_property(_contest.Planet_doubleSpeedRemainingTurns_get, _contest.Planet_doubleSpeedRemainingTurns_set)
    def __repr__(self):
        return type(self).__name__+'('+', '.join([k+':'+str(v(self)) for k,v in self.__swig_getmethods__.items()])+')'

    def __init__(self, *args): 
        """
        __init__(self) -> Planet
        __init__(self, other) -> Planet

        Parameters:
            other: Planet const &

        """
        this = _contest.new_Planet(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_Planet
    __del__ = lambda self : None;
Planet_swigregister = _contest.Planet_swigregister
Planet_swigregister(Planet)

class ScanResult(_object):
    """Proxy of C++ ScanResult class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScanResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScanResult, name)
    __repr__ = _swig_repr
    __swig_setmethods__["planetId"] = _contest.ScanResult_planetId_set
    __swig_getmethods__["planetId"] = _contest.ScanResult_planetId_get
    if _newclass:planetId = _swig_property(_contest.ScanResult_planetId_get, _contest.ScanResult_planetId_set)
    __swig_setmethods__["playerId"] = _contest.ScanResult_playerId_set
    __swig_getmethods__["playerId"] = _contest.ScanResult_playerId_get
    if _newclass:playerId = _swig_property(_contest.ScanResult_playerId_get, _contest.ScanResult_playerId_set)
    __swig_setmethods__["resources"] = _contest.ScanResult_resources_set
    __swig_getmethods__["resources"] = _contest.ScanResult_resources_get
    if _newclass:resources = _swig_property(_contest.ScanResult_resources_get, _contest.ScanResult_resources_set)
    __swig_setmethods__["shipBuildCountLimit"] = _contest.ScanResult_shipBuildCountLimit_set
    __swig_getmethods__["shipBuildCountLimit"] = _contest.ScanResult_shipBuildCountLimit_get
    if _newclass:shipBuildCountLimit = _swig_property(_contest.ScanResult_shipBuildCountLimit_get, _contest.ScanResult_shipBuildCountLimit_set)
    __swig_setmethods__["shipCount"] = _contest.ScanResult_shipCount_set
    __swig_getmethods__["shipCount"] = _contest.ScanResult_shipCount_get
    if _newclass:shipCount = _swig_property(_contest.ScanResult_shipCount_get, _contest.ScanResult_shipCount_set)
    def __repr__(self):
        return type(self).__name__+'('+', '.join([k+':'+str(v(self)) for k,v in self.__swig_getmethods__.items()])+')'

    def __init__(self, *args): 
        """
        __init__(self) -> ScanResult
        __init__(self, other) -> ScanResult

        Parameters:
            other: ScanResult const &

        """
        this = _contest.new_ScanResult(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_ScanResult
    __del__ = lambda self : None;
ScanResult_swigregister = _contest.ScanResult_swigregister
ScanResult_swigregister(ScanResult)

class Fleet(_object):
    """Proxy of C++ Fleet class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Fleet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Fleet, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sourcePlanetId"] = _contest.Fleet_sourcePlanetId_set
    __swig_getmethods__["sourcePlanetId"] = _contest.Fleet_sourcePlanetId_get
    if _newclass:sourcePlanetId = _swig_property(_contest.Fleet_sourcePlanetId_get, _contest.Fleet_sourcePlanetId_set)
    __swig_setmethods__["destinationPlanetId"] = _contest.Fleet_destinationPlanetId_set
    __swig_getmethods__["destinationPlanetId"] = _contest.Fleet_destinationPlanetId_get
    if _newclass:destinationPlanetId = _swig_property(_contest.Fleet_destinationPlanetId_get, _contest.Fleet_destinationPlanetId_set)
    __swig_setmethods__["shipCount"] = _contest.Fleet_shipCount_set
    __swig_getmethods__["shipCount"] = _contest.Fleet_shipCount_get
    if _newclass:shipCount = _swig_property(_contest.Fleet_shipCount_get, _contest.Fleet_shipCount_set)
    __swig_setmethods__["remainingRound"] = _contest.Fleet_remainingRound_set
    __swig_getmethods__["remainingRound"] = _contest.Fleet_remainingRound_get
    if _newclass:remainingRound = _swig_property(_contest.Fleet_remainingRound_get, _contest.Fleet_remainingRound_set)
    def __repr__(self):
        return type(self).__name__+'('+', '.join([k+':'+str(v(self)) for k,v in self.__swig_getmethods__.items()])+')'

    def __init__(self, *args): 
        """
        __init__(self) -> Fleet
        __init__(self, other) -> Fleet

        Parameters:
            other: Fleet const &

        """
        this = _contest.new_Fleet(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_Fleet
    __del__ = lambda self : None;
Fleet_swigregister = _contest.Fleet_swigregister
Fleet_swigregister(Fleet)

class Ennemy(_object):
    """Proxy of C++ Ennemy class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Ennemy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Ennemy, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sourcePlanetId"] = _contest.Ennemy_sourcePlanetId_set
    __swig_getmethods__["sourcePlanetId"] = _contest.Ennemy_sourcePlanetId_get
    if _newclass:sourcePlanetId = _swig_property(_contest.Ennemy_sourcePlanetId_get, _contest.Ennemy_sourcePlanetId_set)
    __swig_setmethods__["destinationPlanetId"] = _contest.Ennemy_destinationPlanetId_set
    __swig_getmethods__["destinationPlanetId"] = _contest.Ennemy_destinationPlanetId_get
    if _newclass:destinationPlanetId = _swig_property(_contest.Ennemy_destinationPlanetId_get, _contest.Ennemy_destinationPlanetId_set)
    __swig_setmethods__["shipCount"] = _contest.Ennemy_shipCount_set
    __swig_getmethods__["shipCount"] = _contest.Ennemy_shipCount_get
    if _newclass:shipCount = _swig_property(_contest.Ennemy_shipCount_get, _contest.Ennemy_shipCount_set)
    __swig_setmethods__["remainingRound"] = _contest.Ennemy_remainingRound_set
    __swig_getmethods__["remainingRound"] = _contest.Ennemy_remainingRound_get
    if _newclass:remainingRound = _swig_property(_contest.Ennemy_remainingRound_get, _contest.Ennemy_remainingRound_set)
    def __repr__(self):
        return type(self).__name__+'('+', '.join([k+':'+str(v(self)) for k,v in self.__swig_getmethods__.items()])+')'

    def __init__(self, *args): 
        """
        __init__(self) -> Ennemy
        __init__(self, other) -> Ennemy

        Parameters:
            other: Ennemy const &

        """
        this = _contest.new_Ennemy(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_Ennemy
    __del__ = lambda self : None;
Ennemy_swigregister = _contest.Ennemy_swigregister
Ennemy_swigregister(Ennemy)

class FightReport(_object):
    """Proxy of C++ FightReport class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FightReport, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FightReport, name)
    __repr__ = _swig_repr
    __swig_setmethods__["planetId"] = _contest.FightReport_planetId_set
    __swig_getmethods__["planetId"] = _contest.FightReport_planetId_get
    if _newclass:planetId = _swig_property(_contest.FightReport_planetId_get, _contest.FightReport_planetId_set)
    __swig_setmethods__["winnerPlayerId"] = _contest.FightReport_winnerPlayerId_set
    __swig_getmethods__["winnerPlayerId"] = _contest.FightReport_winnerPlayerId_get
    if _newclass:winnerPlayerId = _swig_property(_contest.FightReport_winnerPlayerId_get, _contest.FightReport_winnerPlayerId_set)
    __swig_setmethods__["playerCount"] = _contest.FightReport_playerCount_set
    __swig_getmethods__["playerCount"] = _contest.FightReport_playerCount_get
    if _newclass:playerCount = _swig_property(_contest.FightReport_playerCount_get, _contest.FightReport_playerCount_set)
    __swig_setmethods__["remainingShip"] = _contest.FightReport_remainingShip_set
    __swig_getmethods__["remainingShip"] = _contest.FightReport_remainingShip_get
    if _newclass:remainingShip = _swig_property(_contest.FightReport_remainingShip_get, _contest.FightReport_remainingShip_set)
    def __repr__(self):
        return type(self).__name__+'('+', '.join([k+':'+str(v(self)) for k,v in self.__swig_getmethods__.items()])+')'

    def __init__(self, *args): 
        """
        __init__(self) -> FightReport
        __init__(self, other) -> FightReport

        Parameters:
            other: FightReport const &

        """
        this = _contest.new_FightReport(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_FightReport
    __del__ = lambda self : None;
FightReport_swigregister = _contest.FightReport_swigregister
FightReport_swigregister(FightReport)

class GameData(_object):
    """Proxy of C++ GameData class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GameData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GameData, name)
    __repr__ = _swig_repr
    def globalInformations(self):
        """
        globalInformations(self) -> GameInfos

        Parameters:
            self: GameData *

        """
        return _contest.GameData_globalInformations(self)

    def _wrap_planets(self):
        """
        _wrap_planets(self) -> _wrap_PlanetList

        Parameters:
            self: GameData *

        """
        return _contest.GameData__wrap_planets(self)

    def _wrap_scanResults(self):
        """
        _wrap_scanResults(self) -> _wrap_ScanResultList

        Parameters:
            self: GameData *

        """
        return _contest.GameData__wrap_scanResults(self)

    def _wrap_fleets(self):
        """
        _wrap_fleets(self) -> _wrap_FleetList

        Parameters:
            self: GameData *

        """
        return _contest.GameData__wrap_fleets(self)

    def _wrap_enemies(self):
        """
        _wrap_enemies(self) -> _wrap_EnnemyList

        Parameters:
            self: GameData *

        """
        return _contest.GameData__wrap_enemies(self)

    def _wrap_reports(self):
        """
        _wrap_reports(self) -> _wrap_FightReportList

        Parameters:
            self: GameData *

        """
        return _contest.GameData__wrap_reports(self)

    def distance(self, *args):
        """
        distance(self, planetA, planetB) -> int

        Parameters:
            planetA: int
            planetB: int

        """
        return _contest.GameData_distance(self, *args)

    def planets(self):
        vect = self._wrap_planets()
        return [i for i in vect]

    def scanResults(self):
        vect = self._wrap_scanResults()
        return [i for i in vect]

    def fleets(self):
        vect = self._wrap_fleets()
        return [i for i in vect]

    def enemies(self):
        vect = self._wrap_enemies()
        return [i for i in vect]

    def reports(self):
        vect = self._wrap_reports()
        return [i for i in vect]

    def __init__(self, *args): 
        """
        __init__(self, other) -> GameData

        Parameters:
            other: GameData const &

        """
        this = _contest.new_GameData(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_GameData
    __del__ = lambda self : None;
GameData_swigregister = _contest.GameData_swigregister
GameData_swigregister(GameData)

class Session(_object):
    """Proxy of C++ Session class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Session, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Session, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> Session"""
        this = _contest.new_Session()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _contest.delete_Session
    __del__ = lambda self : None;
    def connect(self, *args):
        """
        connect(self, host, port) -> bool

        Parameters:
            host: std::string
            port: int

        """
        return _contest.Session_connect(self, *args)

    def disconnect(self):
        """
        disconnect(self)

        Parameters:
            self: Session *

        """
        return _contest.Session_disconnect(self)

    def login(self, *args):
        """
        login(self, pseudo) -> LoginResult

        Parameters:
            pseudo: std::string

        """
        return _contest.Session_login(self, *args)

    def waitInit(self):
        """
        waitInit(self) -> bool

        Parameters:
            self: Session *

        """
        return _contest.Session_waitInit(self)

    def waitRoundStarting(self):
        """
        waitRoundStarting(self) -> RoundState

        Parameters:
            self: Session *

        """
        return _contest.Session_waitRoundStarting(self)

    def gameData(self):
        """
        gameData(self) -> GameData

        Parameters:
            self: Session *

        """
        return _contest.Session_gameData(self)

    def orderScan(self, *args):
        """
        orderScan(self, planetId)

        Parameters:
            planetId: int

        """
        return _contest.Session_orderScan(self, *args)

    def orderBuild(self, *args):
        """
        orderBuild(self, planetSourceId, shipCount)

        Parameters:
            planetSourceId: int
            shipCount: int

        """
        return _contest.Session_orderBuild(self, *args)

    def orderMove(self, *args):
        """
        orderMove(self, planetSourceId, planetDestinationId, shipCount)

        Parameters:
            planetSourceId: int
            planetDestinationId: int
            shipCount: int

        """
        return _contest.Session_orderMove(self, *args)

    def sendOrders(self):
        """
        sendOrders(self)

        Parameters:
            self: Session *

        """
        return _contest.Session_sendOrders(self)

    def clearOrders(self):
        """
        clearOrders(self)

        Parameters:
            self: Session *

        """
        return _contest.Session_clearOrders(self)

    def isConnected(self):
        """
        isConnected(self) -> bool

        Parameters:
            self: Session *

        """
        return _contest.Session_isConnected(self)

    def lastError(self):
        """
        lastError(self) -> std::string

        Parameters:
            self: Session *

        """
        return _contest.Session_lastError(self)

Session_swigregister = _contest.Session_swigregister
Session_swigregister(Session)

class _wrap_PlanetList(_object):
    """Proxy of C++ std::vector<(Planet)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _wrap_PlanetList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _wrap_PlanetList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::vector< Planet >::size_type

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList___len__(self)

    def pop(self):
        """
        pop(self) -> Planet

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, i, j) -> _wrap_PlanetList

        Parameters:
            i: std::vector< Planet >::difference_type
            j: std::vector< Planet >::difference_type

        """
        return _contest._wrap_PlanetList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, i, j, v=std::vector< Planet,std::allocator< Planet > >())

        Parameters:
            i: std::vector< Planet >::difference_type
            j: std::vector< Planet >::difference_type
            v: std::vector< Planet,std::allocator< Planet > > const &

        __setslice__(self, i, j)

        Parameters:
            i: std::vector< Planet >::difference_type
            j: std::vector< Planet >::difference_type

        """
        return _contest._wrap_PlanetList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, i, j)

        Parameters:
            i: std::vector< Planet >::difference_type
            j: std::vector< Planet >::difference_type

        """
        return _contest._wrap_PlanetList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters:
            i: std::vector< Planet >::difference_type

        __delitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        """
        return _contest._wrap_PlanetList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> _wrap_PlanetList

        Parameters:
            slice: PySliceObject *

        __getitem__(self, i) -> Planet

        Parameters:
            i: std::vector< Planet >::difference_type

        """
        return _contest._wrap_PlanetList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters:
            slice: PySliceObject *
            v: std::vector< Planet,std::allocator< Planet > > const &

        __setitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters:
            i: std::vector< Planet >::difference_type
            x: std::vector< Planet >::value_type const &

        """
        return _contest._wrap_PlanetList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, x)

        Parameters:
            x: std::vector< Planet >::value_type const &

        """
        return _contest._wrap_PlanetList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList_empty(self)

    def size(self):
        """
        size(self) -> std::vector< Planet >::size_type

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList_size(self)

    def clear(self):
        """
        clear(self)

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_clear(self)

    def swap(self, *args):
        """
        swap(self, v)

        Parameters:
            v: std::vector< Planet > &

        """
        return _contest._wrap_PlanetList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< Planet >::allocator_type

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::vector< Planet >::iterator

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_begin(self)

    def end(self):
        """
        end(self) -> std::vector< Planet >::iterator

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::vector< Planet >::reverse_iterator

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::vector< Planet >::reverse_iterator

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        Parameters:
            self: std::vector< Planet > *

        """
        return _contest._wrap_PlanetList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< Planet >::iterator

        Parameters:
            pos: std::vector< Planet >::iterator

        erase(self, first, last) -> std::vector< Planet >::iterator

        Parameters:
            first: std::vector< Planet >::iterator
            last: std::vector< Planet >::iterator

        """
        return _contest._wrap_PlanetList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> _wrap_PlanetList
        __init__(self, arg2) -> _wrap_PlanetList

        Parameters:
            arg2: std::vector< Planet > const &

        __init__(self, size) -> _wrap_PlanetList

        Parameters:
            size: std::vector< Planet >::size_type

        __init__(self, size, value) -> _wrap_PlanetList

        Parameters:
            size: std::vector< Planet >::size_type
            value: std::vector< Planet >::value_type const &

        """
        this = _contest.new__wrap_PlanetList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, x)

        Parameters:
            x: std::vector< Planet >::value_type const &

        """
        return _contest._wrap_PlanetList_push_back(self, *args)

    def front(self):
        """
        front(self) -> Planet

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList_front(self)

    def back(self):
        """
        back(self) -> Planet

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList_back(self)

    def assign(self, *args):
        """
        assign(self, n, x)

        Parameters:
            n: std::vector< Planet >::size_type
            x: std::vector< Planet >::value_type const &

        """
        return _contest._wrap_PlanetList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters:
            new_size: std::vector< Planet >::size_type

        resize(self, new_size, x)

        Parameters:
            new_size: std::vector< Planet >::size_type
            x: std::vector< Planet >::value_type const &

        """
        return _contest._wrap_PlanetList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< Planet >::iterator

        Parameters:
            pos: std::vector< Planet >::iterator
            x: std::vector< Planet >::value_type const &

        insert(self, pos, n, x)

        Parameters:
            pos: std::vector< Planet >::iterator
            n: std::vector< Planet >::size_type
            x: std::vector< Planet >::value_type const &

        """
        return _contest._wrap_PlanetList_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, n)

        Parameters:
            n: std::vector< Planet >::size_type

        """
        return _contest._wrap_PlanetList_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> std::vector< Planet >::size_type

        Parameters:
            self: std::vector< Planet > const *

        """
        return _contest._wrap_PlanetList_capacity(self)

    __swig_destroy__ = _contest.delete__wrap_PlanetList
    __del__ = lambda self : None;
_wrap_PlanetList_swigregister = _contest._wrap_PlanetList_swigregister
_wrap_PlanetList_swigregister(_wrap_PlanetList)

class _wrap_ScanResultList(_object):
    """Proxy of C++ std::vector<(ScanResult)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _wrap_ScanResultList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _wrap_ScanResultList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::vector< ScanResult >::size_type

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList___len__(self)

    def pop(self):
        """
        pop(self) -> ScanResult

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, i, j) -> _wrap_ScanResultList

        Parameters:
            i: std::vector< ScanResult >::difference_type
            j: std::vector< ScanResult >::difference_type

        """
        return _contest._wrap_ScanResultList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, i, j, v=std::vector< ScanResult,std::allocator< ScanResult > >())

        Parameters:
            i: std::vector< ScanResult >::difference_type
            j: std::vector< ScanResult >::difference_type
            v: std::vector< ScanResult,std::allocator< ScanResult > > const &

        __setslice__(self, i, j)

        Parameters:
            i: std::vector< ScanResult >::difference_type
            j: std::vector< ScanResult >::difference_type

        """
        return _contest._wrap_ScanResultList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, i, j)

        Parameters:
            i: std::vector< ScanResult >::difference_type
            j: std::vector< ScanResult >::difference_type

        """
        return _contest._wrap_ScanResultList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters:
            i: std::vector< ScanResult >::difference_type

        __delitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        """
        return _contest._wrap_ScanResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> _wrap_ScanResultList

        Parameters:
            slice: PySliceObject *

        __getitem__(self, i) -> ScanResult

        Parameters:
            i: std::vector< ScanResult >::difference_type

        """
        return _contest._wrap_ScanResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters:
            slice: PySliceObject *
            v: std::vector< ScanResult,std::allocator< ScanResult > > const &

        __setitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters:
            i: std::vector< ScanResult >::difference_type
            x: std::vector< ScanResult >::value_type const &

        """
        return _contest._wrap_ScanResultList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, x)

        Parameters:
            x: std::vector< ScanResult >::value_type const &

        """
        return _contest._wrap_ScanResultList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList_empty(self)

    def size(self):
        """
        size(self) -> std::vector< ScanResult >::size_type

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList_size(self)

    def clear(self):
        """
        clear(self)

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_clear(self)

    def swap(self, *args):
        """
        swap(self, v)

        Parameters:
            v: std::vector< ScanResult > &

        """
        return _contest._wrap_ScanResultList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< ScanResult >::allocator_type

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::vector< ScanResult >::iterator

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_begin(self)

    def end(self):
        """
        end(self) -> std::vector< ScanResult >::iterator

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::vector< ScanResult >::reverse_iterator

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::vector< ScanResult >::reverse_iterator

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        Parameters:
            self: std::vector< ScanResult > *

        """
        return _contest._wrap_ScanResultList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< ScanResult >::iterator

        Parameters:
            pos: std::vector< ScanResult >::iterator

        erase(self, first, last) -> std::vector< ScanResult >::iterator

        Parameters:
            first: std::vector< ScanResult >::iterator
            last: std::vector< ScanResult >::iterator

        """
        return _contest._wrap_ScanResultList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> _wrap_ScanResultList
        __init__(self, arg2) -> _wrap_ScanResultList

        Parameters:
            arg2: std::vector< ScanResult > const &

        __init__(self, size) -> _wrap_ScanResultList

        Parameters:
            size: std::vector< ScanResult >::size_type

        __init__(self, size, value) -> _wrap_ScanResultList

        Parameters:
            size: std::vector< ScanResult >::size_type
            value: std::vector< ScanResult >::value_type const &

        """
        this = _contest.new__wrap_ScanResultList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, x)

        Parameters:
            x: std::vector< ScanResult >::value_type const &

        """
        return _contest._wrap_ScanResultList_push_back(self, *args)

    def front(self):
        """
        front(self) -> ScanResult

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList_front(self)

    def back(self):
        """
        back(self) -> ScanResult

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList_back(self)

    def assign(self, *args):
        """
        assign(self, n, x)

        Parameters:
            n: std::vector< ScanResult >::size_type
            x: std::vector< ScanResult >::value_type const &

        """
        return _contest._wrap_ScanResultList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters:
            new_size: std::vector< ScanResult >::size_type

        resize(self, new_size, x)

        Parameters:
            new_size: std::vector< ScanResult >::size_type
            x: std::vector< ScanResult >::value_type const &

        """
        return _contest._wrap_ScanResultList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< ScanResult >::iterator

        Parameters:
            pos: std::vector< ScanResult >::iterator
            x: std::vector< ScanResult >::value_type const &

        insert(self, pos, n, x)

        Parameters:
            pos: std::vector< ScanResult >::iterator
            n: std::vector< ScanResult >::size_type
            x: std::vector< ScanResult >::value_type const &

        """
        return _contest._wrap_ScanResultList_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, n)

        Parameters:
            n: std::vector< ScanResult >::size_type

        """
        return _contest._wrap_ScanResultList_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> std::vector< ScanResult >::size_type

        Parameters:
            self: std::vector< ScanResult > const *

        """
        return _contest._wrap_ScanResultList_capacity(self)

    __swig_destroy__ = _contest.delete__wrap_ScanResultList
    __del__ = lambda self : None;
_wrap_ScanResultList_swigregister = _contest._wrap_ScanResultList_swigregister
_wrap_ScanResultList_swigregister(_wrap_ScanResultList)

class _wrap_FleetList(_object):
    """Proxy of C++ std::vector<(Fleet)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _wrap_FleetList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _wrap_FleetList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::vector< Fleet >::size_type

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList___len__(self)

    def pop(self):
        """
        pop(self) -> Fleet

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, i, j) -> _wrap_FleetList

        Parameters:
            i: std::vector< Fleet >::difference_type
            j: std::vector< Fleet >::difference_type

        """
        return _contest._wrap_FleetList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, i, j, v=std::vector< Fleet,std::allocator< Fleet > >())

        Parameters:
            i: std::vector< Fleet >::difference_type
            j: std::vector< Fleet >::difference_type
            v: std::vector< Fleet,std::allocator< Fleet > > const &

        __setslice__(self, i, j)

        Parameters:
            i: std::vector< Fleet >::difference_type
            j: std::vector< Fleet >::difference_type

        """
        return _contest._wrap_FleetList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, i, j)

        Parameters:
            i: std::vector< Fleet >::difference_type
            j: std::vector< Fleet >::difference_type

        """
        return _contest._wrap_FleetList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters:
            i: std::vector< Fleet >::difference_type

        __delitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        """
        return _contest._wrap_FleetList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> _wrap_FleetList

        Parameters:
            slice: PySliceObject *

        __getitem__(self, i) -> Fleet

        Parameters:
            i: std::vector< Fleet >::difference_type

        """
        return _contest._wrap_FleetList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters:
            slice: PySliceObject *
            v: std::vector< Fleet,std::allocator< Fleet > > const &

        __setitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters:
            i: std::vector< Fleet >::difference_type
            x: std::vector< Fleet >::value_type const &

        """
        return _contest._wrap_FleetList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, x)

        Parameters:
            x: std::vector< Fleet >::value_type const &

        """
        return _contest._wrap_FleetList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList_empty(self)

    def size(self):
        """
        size(self) -> std::vector< Fleet >::size_type

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList_size(self)

    def clear(self):
        """
        clear(self)

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_clear(self)

    def swap(self, *args):
        """
        swap(self, v)

        Parameters:
            v: std::vector< Fleet > &

        """
        return _contest._wrap_FleetList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< Fleet >::allocator_type

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::vector< Fleet >::iterator

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_begin(self)

    def end(self):
        """
        end(self) -> std::vector< Fleet >::iterator

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::vector< Fleet >::reverse_iterator

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::vector< Fleet >::reverse_iterator

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        Parameters:
            self: std::vector< Fleet > *

        """
        return _contest._wrap_FleetList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< Fleet >::iterator

        Parameters:
            pos: std::vector< Fleet >::iterator

        erase(self, first, last) -> std::vector< Fleet >::iterator

        Parameters:
            first: std::vector< Fleet >::iterator
            last: std::vector< Fleet >::iterator

        """
        return _contest._wrap_FleetList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> _wrap_FleetList
        __init__(self, arg2) -> _wrap_FleetList

        Parameters:
            arg2: std::vector< Fleet > const &

        __init__(self, size) -> _wrap_FleetList

        Parameters:
            size: std::vector< Fleet >::size_type

        __init__(self, size, value) -> _wrap_FleetList

        Parameters:
            size: std::vector< Fleet >::size_type
            value: std::vector< Fleet >::value_type const &

        """
        this = _contest.new__wrap_FleetList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, x)

        Parameters:
            x: std::vector< Fleet >::value_type const &

        """
        return _contest._wrap_FleetList_push_back(self, *args)

    def front(self):
        """
        front(self) -> Fleet

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList_front(self)

    def back(self):
        """
        back(self) -> Fleet

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList_back(self)

    def assign(self, *args):
        """
        assign(self, n, x)

        Parameters:
            n: std::vector< Fleet >::size_type
            x: std::vector< Fleet >::value_type const &

        """
        return _contest._wrap_FleetList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters:
            new_size: std::vector< Fleet >::size_type

        resize(self, new_size, x)

        Parameters:
            new_size: std::vector< Fleet >::size_type
            x: std::vector< Fleet >::value_type const &

        """
        return _contest._wrap_FleetList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< Fleet >::iterator

        Parameters:
            pos: std::vector< Fleet >::iterator
            x: std::vector< Fleet >::value_type const &

        insert(self, pos, n, x)

        Parameters:
            pos: std::vector< Fleet >::iterator
            n: std::vector< Fleet >::size_type
            x: std::vector< Fleet >::value_type const &

        """
        return _contest._wrap_FleetList_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, n)

        Parameters:
            n: std::vector< Fleet >::size_type

        """
        return _contest._wrap_FleetList_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> std::vector< Fleet >::size_type

        Parameters:
            self: std::vector< Fleet > const *

        """
        return _contest._wrap_FleetList_capacity(self)

    __swig_destroy__ = _contest.delete__wrap_FleetList
    __del__ = lambda self : None;
_wrap_FleetList_swigregister = _contest._wrap_FleetList_swigregister
_wrap_FleetList_swigregister(_wrap_FleetList)

class _wrap_EnnemyList(_object):
    """Proxy of C++ std::vector<(Ennemy)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _wrap_EnnemyList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _wrap_EnnemyList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::vector< Ennemy >::size_type

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList___len__(self)

    def pop(self):
        """
        pop(self) -> Ennemy

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, i, j) -> _wrap_EnnemyList

        Parameters:
            i: std::vector< Ennemy >::difference_type
            j: std::vector< Ennemy >::difference_type

        """
        return _contest._wrap_EnnemyList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, i, j, v=std::vector< Ennemy,std::allocator< Ennemy > >())

        Parameters:
            i: std::vector< Ennemy >::difference_type
            j: std::vector< Ennemy >::difference_type
            v: std::vector< Ennemy,std::allocator< Ennemy > > const &

        __setslice__(self, i, j)

        Parameters:
            i: std::vector< Ennemy >::difference_type
            j: std::vector< Ennemy >::difference_type

        """
        return _contest._wrap_EnnemyList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, i, j)

        Parameters:
            i: std::vector< Ennemy >::difference_type
            j: std::vector< Ennemy >::difference_type

        """
        return _contest._wrap_EnnemyList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters:
            i: std::vector< Ennemy >::difference_type

        __delitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        """
        return _contest._wrap_EnnemyList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> _wrap_EnnemyList

        Parameters:
            slice: PySliceObject *

        __getitem__(self, i) -> Ennemy

        Parameters:
            i: std::vector< Ennemy >::difference_type

        """
        return _contest._wrap_EnnemyList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters:
            slice: PySliceObject *
            v: std::vector< Ennemy,std::allocator< Ennemy > > const &

        __setitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters:
            i: std::vector< Ennemy >::difference_type
            x: std::vector< Ennemy >::value_type const &

        """
        return _contest._wrap_EnnemyList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, x)

        Parameters:
            x: std::vector< Ennemy >::value_type const &

        """
        return _contest._wrap_EnnemyList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList_empty(self)

    def size(self):
        """
        size(self) -> std::vector< Ennemy >::size_type

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList_size(self)

    def clear(self):
        """
        clear(self)

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_clear(self)

    def swap(self, *args):
        """
        swap(self, v)

        Parameters:
            v: std::vector< Ennemy > &

        """
        return _contest._wrap_EnnemyList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< Ennemy >::allocator_type

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::vector< Ennemy >::iterator

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_begin(self)

    def end(self):
        """
        end(self) -> std::vector< Ennemy >::iterator

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::vector< Ennemy >::reverse_iterator

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::vector< Ennemy >::reverse_iterator

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        Parameters:
            self: std::vector< Ennemy > *

        """
        return _contest._wrap_EnnemyList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< Ennemy >::iterator

        Parameters:
            pos: std::vector< Ennemy >::iterator

        erase(self, first, last) -> std::vector< Ennemy >::iterator

        Parameters:
            first: std::vector< Ennemy >::iterator
            last: std::vector< Ennemy >::iterator

        """
        return _contest._wrap_EnnemyList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> _wrap_EnnemyList
        __init__(self, arg2) -> _wrap_EnnemyList

        Parameters:
            arg2: std::vector< Ennemy > const &

        __init__(self, size) -> _wrap_EnnemyList

        Parameters:
            size: std::vector< Ennemy >::size_type

        __init__(self, size, value) -> _wrap_EnnemyList

        Parameters:
            size: std::vector< Ennemy >::size_type
            value: std::vector< Ennemy >::value_type const &

        """
        this = _contest.new__wrap_EnnemyList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, x)

        Parameters:
            x: std::vector< Ennemy >::value_type const &

        """
        return _contest._wrap_EnnemyList_push_back(self, *args)

    def front(self):
        """
        front(self) -> Ennemy

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList_front(self)

    def back(self):
        """
        back(self) -> Ennemy

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList_back(self)

    def assign(self, *args):
        """
        assign(self, n, x)

        Parameters:
            n: std::vector< Ennemy >::size_type
            x: std::vector< Ennemy >::value_type const &

        """
        return _contest._wrap_EnnemyList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters:
            new_size: std::vector< Ennemy >::size_type

        resize(self, new_size, x)

        Parameters:
            new_size: std::vector< Ennemy >::size_type
            x: std::vector< Ennemy >::value_type const &

        """
        return _contest._wrap_EnnemyList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< Ennemy >::iterator

        Parameters:
            pos: std::vector< Ennemy >::iterator
            x: std::vector< Ennemy >::value_type const &

        insert(self, pos, n, x)

        Parameters:
            pos: std::vector< Ennemy >::iterator
            n: std::vector< Ennemy >::size_type
            x: std::vector< Ennemy >::value_type const &

        """
        return _contest._wrap_EnnemyList_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, n)

        Parameters:
            n: std::vector< Ennemy >::size_type

        """
        return _contest._wrap_EnnemyList_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> std::vector< Ennemy >::size_type

        Parameters:
            self: std::vector< Ennemy > const *

        """
        return _contest._wrap_EnnemyList_capacity(self)

    __swig_destroy__ = _contest.delete__wrap_EnnemyList
    __del__ = lambda self : None;
_wrap_EnnemyList_swigregister = _contest._wrap_EnnemyList_swigregister
_wrap_EnnemyList_swigregister(_wrap_EnnemyList)

class _wrap_FightReportList(_object):
    """Proxy of C++ std::vector<(FightReport)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _wrap_FightReportList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _wrap_FightReportList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::vector< FightReport >::size_type

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList___len__(self)

    def pop(self):
        """
        pop(self) -> FightReport

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, i, j) -> _wrap_FightReportList

        Parameters:
            i: std::vector< FightReport >::difference_type
            j: std::vector< FightReport >::difference_type

        """
        return _contest._wrap_FightReportList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, i, j, v=std::vector< FightReport,std::allocator< FightReport > >())

        Parameters:
            i: std::vector< FightReport >::difference_type
            j: std::vector< FightReport >::difference_type
            v: std::vector< FightReport,std::allocator< FightReport > > const &

        __setslice__(self, i, j)

        Parameters:
            i: std::vector< FightReport >::difference_type
            j: std::vector< FightReport >::difference_type

        """
        return _contest._wrap_FightReportList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, i, j)

        Parameters:
            i: std::vector< FightReport >::difference_type
            j: std::vector< FightReport >::difference_type

        """
        return _contest._wrap_FightReportList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters:
            i: std::vector< FightReport >::difference_type

        __delitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        """
        return _contest._wrap_FightReportList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> _wrap_FightReportList

        Parameters:
            slice: PySliceObject *

        __getitem__(self, i) -> FightReport

        Parameters:
            i: std::vector< FightReport >::difference_type

        """
        return _contest._wrap_FightReportList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters:
            slice: PySliceObject *
            v: std::vector< FightReport,std::allocator< FightReport > > const &

        __setitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters:
            i: std::vector< FightReport >::difference_type
            x: std::vector< FightReport >::value_type const &

        """
        return _contest._wrap_FightReportList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, x)

        Parameters:
            x: std::vector< FightReport >::value_type const &

        """
        return _contest._wrap_FightReportList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList_empty(self)

    def size(self):
        """
        size(self) -> std::vector< FightReport >::size_type

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList_size(self)

    def clear(self):
        """
        clear(self)

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_clear(self)

    def swap(self, *args):
        """
        swap(self, v)

        Parameters:
            v: std::vector< FightReport > &

        """
        return _contest._wrap_FightReportList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< FightReport >::allocator_type

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::vector< FightReport >::iterator

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_begin(self)

    def end(self):
        """
        end(self) -> std::vector< FightReport >::iterator

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::vector< FightReport >::reverse_iterator

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::vector< FightReport >::reverse_iterator

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        Parameters:
            self: std::vector< FightReport > *

        """
        return _contest._wrap_FightReportList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< FightReport >::iterator

        Parameters:
            pos: std::vector< FightReport >::iterator

        erase(self, first, last) -> std::vector< FightReport >::iterator

        Parameters:
            first: std::vector< FightReport >::iterator
            last: std::vector< FightReport >::iterator

        """
        return _contest._wrap_FightReportList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> _wrap_FightReportList
        __init__(self, arg2) -> _wrap_FightReportList

        Parameters:
            arg2: std::vector< FightReport > const &

        __init__(self, size) -> _wrap_FightReportList

        Parameters:
            size: std::vector< FightReport >::size_type

        __init__(self, size, value) -> _wrap_FightReportList

        Parameters:
            size: std::vector< FightReport >::size_type
            value: std::vector< FightReport >::value_type const &

        """
        this = _contest.new__wrap_FightReportList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, x)

        Parameters:
            x: std::vector< FightReport >::value_type const &

        """
        return _contest._wrap_FightReportList_push_back(self, *args)

    def front(self):
        """
        front(self) -> FightReport

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList_front(self)

    def back(self):
        """
        back(self) -> FightReport

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList_back(self)

    def assign(self, *args):
        """
        assign(self, n, x)

        Parameters:
            n: std::vector< FightReport >::size_type
            x: std::vector< FightReport >::value_type const &

        """
        return _contest._wrap_FightReportList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters:
            new_size: std::vector< FightReport >::size_type

        resize(self, new_size, x)

        Parameters:
            new_size: std::vector< FightReport >::size_type
            x: std::vector< FightReport >::value_type const &

        """
        return _contest._wrap_FightReportList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< FightReport >::iterator

        Parameters:
            pos: std::vector< FightReport >::iterator
            x: std::vector< FightReport >::value_type const &

        insert(self, pos, n, x)

        Parameters:
            pos: std::vector< FightReport >::iterator
            n: std::vector< FightReport >::size_type
            x: std::vector< FightReport >::value_type const &

        """
        return _contest._wrap_FightReportList_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, n)

        Parameters:
            n: std::vector< FightReport >::size_type

        """
        return _contest._wrap_FightReportList_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> std::vector< FightReport >::size_type

        Parameters:
            self: std::vector< FightReport > const *

        """
        return _contest._wrap_FightReportList_capacity(self)

    __swig_destroy__ = _contest.delete__wrap_FightReportList
    __del__ = lambda self : None;
_wrap_FightReportList_swigregister = _contest._wrap_FightReportList_swigregister
_wrap_FightReportList_swigregister(_wrap_FightReportList)

class _wrap_IntList(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _wrap_IntList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _wrap_IntList, name)
    __repr__ = _swig_repr
    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList___nonzero__(self)

    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList___bool__(self)

    def __len__(self):
        """
        __len__(self) -> std::vector< int >::size_type

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList___len__(self)

    def pop(self):
        """
        pop(self) -> std::vector< int >::value_type

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, i, j) -> _wrap_IntList

        Parameters:
            i: std::vector< int >::difference_type
            j: std::vector< int >::difference_type

        """
        return _contest._wrap_IntList___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, i, j, v=std::vector< int,std::allocator< int > >())

        Parameters:
            i: std::vector< int >::difference_type
            j: std::vector< int >::difference_type
            v: std::vector< int,std::allocator< int > > const &

        __setslice__(self, i, j)

        Parameters:
            i: std::vector< int >::difference_type
            j: std::vector< int >::difference_type

        """
        return _contest._wrap_IntList___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, i, j)

        Parameters:
            i: std::vector< int >::difference_type
            j: std::vector< int >::difference_type

        """
        return _contest._wrap_IntList___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters:
            i: std::vector< int >::difference_type

        __delitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        """
        return _contest._wrap_IntList___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> _wrap_IntList

        Parameters:
            slice: PySliceObject *

        __getitem__(self, i) -> std::vector< int >::value_type const &

        Parameters:
            i: std::vector< int >::difference_type

        """
        return _contest._wrap_IntList___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters:
            slice: PySliceObject *
            v: std::vector< int,std::allocator< int > > const &

        __setitem__(self, slice)

        Parameters:
            slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters:
            i: std::vector< int >::difference_type
            x: std::vector< int >::value_type const &

        """
        return _contest._wrap_IntList___setitem__(self, *args)

    def append(self, *args):
        """
        append(self, x)

        Parameters:
            x: std::vector< int >::value_type const &

        """
        return _contest._wrap_IntList_append(self, *args)

    def empty(self):
        """
        empty(self) -> bool

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList_empty(self)

    def size(self):
        """
        size(self) -> std::vector< int >::size_type

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList_size(self)

    def clear(self):
        """
        clear(self)

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_clear(self)

    def swap(self, *args):
        """
        swap(self, v)

        Parameters:
            v: std::vector< int > &

        """
        return _contest._wrap_IntList_swap(self, *args)

    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< int >::allocator_type

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList_get_allocator(self)

    def begin(self):
        """
        begin(self) -> std::vector< int >::iterator

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_begin(self)

    def end(self):
        """
        end(self) -> std::vector< int >::iterator

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_end(self)

    def rbegin(self):
        """
        rbegin(self) -> std::vector< int >::reverse_iterator

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_rbegin(self)

    def rend(self):
        """
        rend(self) -> std::vector< int >::reverse_iterator

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_rend(self)

    def pop_back(self):
        """
        pop_back(self)

        Parameters:
            self: std::vector< int > *

        """
        return _contest._wrap_IntList_pop_back(self)

    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< int >::iterator

        Parameters:
            pos: std::vector< int >::iterator

        erase(self, first, last) -> std::vector< int >::iterator

        Parameters:
            first: std::vector< int >::iterator
            last: std::vector< int >::iterator

        """
        return _contest._wrap_IntList_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> _wrap_IntList
        __init__(self, arg2) -> _wrap_IntList

        Parameters:
            arg2: std::vector< int > const &

        __init__(self, size) -> _wrap_IntList

        Parameters:
            size: std::vector< int >::size_type

        __init__(self, size, value) -> _wrap_IntList

        Parameters:
            size: std::vector< int >::size_type
            value: std::vector< int >::value_type const &

        """
        this = _contest.new__wrap_IntList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """
        push_back(self, x)

        Parameters:
            x: std::vector< int >::value_type const &

        """
        return _contest._wrap_IntList_push_back(self, *args)

    def front(self):
        """
        front(self) -> std::vector< int >::value_type const &

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList_front(self)

    def back(self):
        """
        back(self) -> std::vector< int >::value_type const &

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList_back(self)

    def assign(self, *args):
        """
        assign(self, n, x)

        Parameters:
            n: std::vector< int >::size_type
            x: std::vector< int >::value_type const &

        """
        return _contest._wrap_IntList_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters:
            new_size: std::vector< int >::size_type

        resize(self, new_size, x)

        Parameters:
            new_size: std::vector< int >::size_type
            x: std::vector< int >::value_type const &

        """
        return _contest._wrap_IntList_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< int >::iterator

        Parameters:
            pos: std::vector< int >::iterator
            x: std::vector< int >::value_type const &

        insert(self, pos, n, x)

        Parameters:
            pos: std::vector< int >::iterator
            n: std::vector< int >::size_type
            x: std::vector< int >::value_type const &

        """
        return _contest._wrap_IntList_insert(self, *args)

    def reserve(self, *args):
        """
        reserve(self, n)

        Parameters:
            n: std::vector< int >::size_type

        """
        return _contest._wrap_IntList_reserve(self, *args)

    def capacity(self):
        """
        capacity(self) -> std::vector< int >::size_type

        Parameters:
            self: std::vector< int > const *

        """
        return _contest._wrap_IntList_capacity(self)

    __swig_destroy__ = _contest.delete__wrap_IntList
    __del__ = lambda self : None;
_wrap_IntList_swigregister = _contest._wrap_IntList_swigregister
_wrap_IntList_swigregister(_wrap_IntList)

# This file is compatible with both classic and new-style classes.


